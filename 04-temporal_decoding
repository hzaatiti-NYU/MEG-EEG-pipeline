#Multivariate Statistics (Decoding / MVPA) on MEG/EEG Data
%matplotlib qt
import pathlib
import matplotlib
import matplotlib.pyplot as plt
import mne

matplotlib.use('Qt5Agg')
mne.set_log_level('warning')
#Load epochs
epochs = mne.read_epochs(pathlib.Path('out_data') / 'epochs_epo.fif')
epochs.apply_baseline((None, 0))

#Calculate empirical evoked difference
evoked_diff = mne.combine_evoked(
    [epochs['eyes_closed'].average(),
     epochs['eyes_open'].average()],
    weights=[1, -1]  # Subtraction
)

evoked_diff.plot(gfp=True)
mne.viz.plot_compare_evokeds(
    [epochs['eyes_closed'].average(),
     epochs['eyes_open'].average(),
     evoked_diff]
)
# Equalize the number of epochs: To keep chance level at 50% accuracy, we first equalize the number of epochs in each condition.

epochs.equalize_event_counts(epochs.event_id)

# Create input X and response y


import numpy as np

# Create an vector with length = no. of trials.
y = np.empty(len(epochs.events), dtype=int)  

# Which trials are eyes_closed, which are eyes_open?
idx_left = epochs.events[:, 2] == epochs.event_id[' eyes_closed']
idx_right = epochs.events[:, 2] == epochs.event_id['eyes_open']

# Encode: eyes_closed = 0, eyes_open = 1.
y[idx_left] = 0
y[idx_right] = 1

print(y)
print(f'\nSize of y: {y.size}')

# Now, let's create the input matrix, X

epochs_grad = epochs.copy().pick_types(meg='grad')

# Retrieve the data as a NumPy array.
# The array has the shape: (n_trials, n_channels, n_timepoints)
data = epochs_grad.get_data()
print(data.shape)

n_trials = data.shape[0]

X = data.reshape(n_trials, -1)
print(X.shape)
