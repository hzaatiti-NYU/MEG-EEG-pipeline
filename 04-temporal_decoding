#Multivariate Statistics (Decoding / MVPA) on MEG/EEG Data
%matplotlib qt
import pathlib
import matplotlib
import matplotlib.pyplot as plt
import mne

matplotlib.use('Qt5Agg')
mne.set_log_level('warning')
#Load epochs
epochs = mne.read_epochs(pathlib.Path('out_data') / 'epochs_epo.fif')
epochs.apply_baseline((None, 0))

#Calculate empirical evoked difference
evoked_diff = mne.combine_evoked(
    [epochs['eyes_closed'].average(),
     epochs['eyes_open'].average()],
    weights=[1, -1]  # Subtraction
)

evoked_diff.plot(gfp=True)
mne.viz.plot_compare_evokeds(
    [epochs['eyes_closed'].average(),
     epochs['eyes_open'].average(),
     evoked_diff]
)
# Equalize the number of epochs: To keep chance level at 50% accuracy, we first equalize the number of epochs in each condition.

epochs.equalize_event_counts(epochs.event_id)

# Create input X and response y


import numpy as np

# Create an vector with length = no. of trials.
y = np.empty(len(epochs.events), dtype=int)  

# Which trials are eyes_closed, which are eyes_open?
idx_left = epochs.events[:, 2] == epochs.event_id[' eyes_closed']
idx_right = epochs.events[:, 2] == epochs.event_id['eyes_open']

# Encode: eyes_closed = 0, eyes_open = 1.
y[idx_left] = 0
y[idx_right] = 1

print(y)
print(f'\nSize of y: {y.size}')

# Now, let's create the input matrix, X

epochs_grad = epochs.copy().pick_types(meg='grad')

# Retrieve the data as a NumPy array.
# The array has the shape: (n_trials, n_channels, n_timepoints)
data = epochs_grad.get_data()
print(data.shape)

n_trials = data.shape[0]

X = data.reshape(n_trials, -1)
print(X.shape)

# Create a classifier
from sklearn.pipeline import make_pipeline
from mne.decoding import Scaler, Vectorizer, cross_val_multiscore

# First, create X and y.
epochs_grad = epochs.copy().pick_types(meg='grad')
X = epochs_grad.get_data()
y = epochs_grad.events[:, 2]

# Classifier pipeline.
clf = make_pipeline(
    # An MNE scaler that correctly handles different channel types â€“
    # isn't that great?!
    Scaler(epochs_grad.info),
    # Remember this annoying and error-prone NumPy array reshaping we had to do
    # earlier? Not anymore, thanks to the MNE vectorizer!
    Vectorizer(),
    # And, finally, the actual classifier.
    LogisticRegression())

# Run cross-validation.
# Note that we're using MNE's cross_val_multiscore() here, not scikit-learn's
# cross_val_score() as above. We simply pass the number of desired CV splits,
# and MNE will automatically do the rest for us.
n_splits = 5
scoring = 'roc_auc'
scores = cross_val_multiscore(clf, X, y, cv=5, scoring='roc_auc')

# Mean and standard deviation of ROC AUC across cross-validation runs.
roc_auc_mean = round(np.mean(scores), 3)
roc_auc_std = round(np.std(scores), 3)

print(f'CV scores: {scores}')
print(f'Mean ROC AUC = {roc_auc_mean:.3f} (SD = {roc_auc_std:.3f})')

# Decoding over time
from sklearn.preprocessing import StandardScaler
from mne.decoding import SlidingEstimator

# First, create X and y.
epochs_auditory_grad = epochs_auditory.copy().pick_types(meg='grad')
X = epochs_grad.get_data()
y = epochs_grad.events[:, 2]

# Classifier pipeline. No need for vectorization as in the previous example.
clf = make_pipeline(StandardScaler(),
                    LogisticRegression())

# The "sliding estimator" will train the classifier at each time point.
scoring = 'roc_auc'
time_decoder = SlidingEstimator(clf, scoring=scoring, n_jobs=1, verbose=True)

# Run cross-validation.
n_splits = 5
scores = cross_val_multiscore(time_decoder, X, y, cv=5, n_jobs=1)

# Mean scores across cross-validation splits, for each time point.
mean_scores = np.mean(scores, axis=0)

# Mean score across all time points.
mean_across_all_times = round(np.mean(scores), 3)
print(f'\n=> Mean CV score across all time points: {mean_across_all_times:.3f}')

# Plot the classification results
fig, ax = plt.subplots()

ax.axhline(0.5, color='k', linestyle='--', label='chance')  # AUC = 0.5
ax.axvline(0, color='k', linestyle='-')  # Mark time point zero.
ax.plot(epochs.times, mean_scores, label='score')

ax.set_xlabel('Time (s)')
ax.set_ylabel('Mean ROC AUC')
ax.legend()
ax.set_title('Left vs Right')
fig.suptitle('Sensor Space Decoding')
